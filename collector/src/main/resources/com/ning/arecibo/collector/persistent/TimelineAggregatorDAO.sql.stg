group TimelineAggregatorDAO;

getTimelineAggregationCandidates() ::= <<
  select
    c.chunk_id
  , c.host_id
  , c.sample_kind_id
  , c.start_time
  , c.end_time
  , c.in_row_samples
  , c.blob_samples
  , c.sample_count
  , c.aggregation_level
  , c.not_valid
  , c.dont_aggregate
  , h.chunk_count
  from timeline_chunks c
  join
    (select count(*) chunk_count, host_id, sample_kind_id
     from timeline_chunks
     where aggregation_level = :aggregationLevel and not_valid = 0
     group by host_id, sample_kind_id) h
   where c.host_id = h.host_id and c.sample_kind_id = h.sample_kind_id
     and c.host_id != 0
     and c.aggregation_level = :aggregationLevel and c.not_valid = 0
     and c.dont_aggregate = 0
     and h.chunk_count >= :chunksNeeded
   order by c.host_id, c.sample_kind_id, c.start_time
   limit :aggregationBatchSize;
 >>

 getAggregationCandidatesForHostIdAndSampleKindIds(sampleKindIds) ::= <<
  select
    chunk_id
  , host_id
  , sample_kind_id
  , start_time
  , end_time
  , in_row_samples
  , blob_samples
  , sample_count
  , aggregation_level
  , not_valid
  , dont_aggregate
  from timeline_chunks
  where host_id = :host_id
  and sample_kind_id in (<sampleKindIds>)
  ;
>>

getLastInsertedId() ::= <<
  select last_insert_id();
>>

makeTimelineChunkValid() ::= <<
  update timeline_chunks
  set not_valid = 0
  where chunk_id = :chunkId
  ;
>>

makeTimelineChunksInvalid(chunkIds) ::=<<
  update timeline_chunks
  set not_valid = 1
  where chunk_id in (<chunkIds>)
  ;
>>

deleteTimelineChunks(chunkIds) ::=<<
  delete from timeline_chunks where chunk_id in (<chunkIds>);
>>
