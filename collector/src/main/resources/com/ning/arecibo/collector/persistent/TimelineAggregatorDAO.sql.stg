group TimelineAggregatorDAO;

getTimelineAggregationCandidates() ::= <<
  select
    sample_timeline_id
  , host_id
  , sample_kind_id
  , start_time
  , end_time
  , in_row_samples
  , blob_samples
  , sample_count
  , aggregation_level
  , not_valid
  from timeline_chunks
  where not_valid = 0
  and aggregation_level = :aggregationLevel
  and host_id != 0
  order by host_id, sample_kind_id, start_time
  ;
>>

getHostIdsAndSampleIdsOfAggregationCandidates() ::= <<
  select * from
    (select count(*) as chunk_count, hostId, sampleKindId
     from timeline_chunks
     where aggregation_level = :aggregationLevel and not_valid = 0) t
   where chunk_count >= :chunksNeeded
   order by host_id, sample_kind_id
   limit :limit
   ;
 >>

 getAggregationCandidatesForHostIdAndSampleKindIds(sampleKindIds) ::= <<
  select
    sample_timeline_id
  , host_id
  , sample_kind_id
  , start_time
  , end_time
  , in_row_samples
  , blob_samples
  , sample_count
  , aggregation_level
  , not_valid
  from timeline_chunks
  where host_id = :host_id
  and sample_kind_id in (<sampleKindIds>)
  ;
>>
insertNewInvalidTimelineChunk() ::= <<
  insert into timeline_chunks (host_id, sample_kind_id, start_time, end_time, sample_count, in_row_samples, blob_samples, aggregation_level, not_valid)
  values (:hostId, :sampleKindId, :startTime, :endTime, :sampleCount, :inRowSamples, :blobSamples, :aggregationLevel, 1);
>>

getLastInsertedId() ::= <<
  select last_insert_id();
>>

makeTimelineChunkValid() ::= <<
  update timeline_chunks
  set not_valid = 0
  where sample_timeline_id = :sampleTimelineId
  ;
>>

makeTimelineChunksInvalid(sampleTimelineIds) ::=<<
  update timeline_chunks
  set not_valid = 1
  where sample_timeline_id in (<sampleTimelineIds>)
  ;
>>

deleteTimelineChunks(sampleTimelineIds) ::=<<
  delete from timeline_chunks where sample_timeline_id in (<sampleTimelineIds>);
>>
